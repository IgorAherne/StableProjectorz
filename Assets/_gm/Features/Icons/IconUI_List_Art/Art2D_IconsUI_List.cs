using SimpleFileBrowser; // CHANGED: Replaced Crosstales.FB
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UnityEngine;
using UnityEngine.InputSystem;


namespace spz {

	//shows a collection of rectangles, each containing a texture.
	//can be used for previewing the images generated by stable diffusion server.
	public class Art2D_IconsUI_List : IconsUI_List{
	    public static Art2D_IconsUI_List instance { get; private set; } = null;

	    [SerializeField] IconUI _icon_PREFAB;

	    public static Action<IconUI> _Act_mainIcon_selected { get; set; } = null;


	    //When we begin generation and will need to display the progress of images generation.
	    protected override bool OnWillGenerate_isMyKind( GenData2D genData, out IconUI prefab_ ){
	        prefab_ = null;
	        bool relevantToMe  = genData.kind==GenerationData_Kind.SD_ProjTextures;
	             relevantToMe |= genData.kind==GenerationData_Kind.UvTextures_FromFile;
	             relevantToMe |= genData.kind==GenerationData_Kind.UvPaintedBrush;
	             relevantToMe |= genData.kind==GenerationData_Kind.AmbientOcclusion;
	             relevantToMe |= genData.kind==GenerationData_Kind.UvNormals_FromFile;
	        if (!relevantToMe){ return false; }
       
	        prefab_ = _icon_PREFAB;
	        return true;
	    }

	    protected override void onIconUI_Selected(IconUI icon, GenerationData_Kind kind){
	        bool relevantToMe  = kind==GenerationData_Kind.SD_ProjTextures;
	             relevantToMe |= kind==GenerationData_Kind.UvTextures_FromFile;
	             relevantToMe |= kind==GenerationData_Kind.UvPaintedBrush;
	             relevantToMe |= kind==GenerationData_Kind.AmbientOcclusion;
	             relevantToMe |= kind==GenerationData_Kind.UvNormals_FromFile;
	        if (!relevantToMe){ return; }
	        // Allows user to cancel the hiding/isolation mode, when changing to any icon.
	        // Helpful if they accidentally enabled this mode and not sure how to switch it off.
	        // NOTICE: Only if not already shown as solo!!
	        // Otherwise, right clicking in a solo'ed-icon reveals all icons, annoyingly:
	        if (icon._myIconGroup.showMyIcons_as_solo == false){
	            base.disable_IsSolo_inAllGroups( anotherGroupRemains_asSolo:false,  sendEventsToIcons:true );
	        }
	        //AFTER the visiblity (potentially) changed, assign the icon as main:
	        if(relevantToMe){ 
	            base._mainSelectedIcon = icon;
	            _Act_mainIcon_selected?.Invoke(icon);
	        }
	    }


	    public bool OnImport_DragAndDrop( List<string> files){
	        Images_ImportHelper.instance.OnImport_DragAndDrop( GenerationData_Kind.UvTextures_FromFile,  files, 
	                                                           base.OnImportCustomImage_OK, base.OnImportCustomImage_Fail);
	        return true;//indicate we consumed this;
	    }


	    protected override void OnCustomImageImported_maybeChangeKind( ref GenerationData_Kind kind ){
	    }


	    protected override void OnMergeAllIcons_Button(){
	        if(Gen3D_API.instance.isBusy){ return; }

	        if(_genGUID_to_iconGroup.Count==0){ return; }
	        var sd = StableDiffusion_Hub.instance;
	        if(sd._finalPreparations_beforeGen || sd._generating){ return; }//avoid collapsing with progress textures.

	        string msg = $"Merge <b>ALL ICONS</b>\nCareful, there is no CTRL+Z!";
	        ConfirmPopup_UI.instance.Show(msg, onYes, onNo:null);
        
	        void onYes() => Save_MGR.instance.MergeIcons( onHaveAlbedo );

	        void onHaveAlbedo( Dictionary<Texture2D,UDIM_Sector> albedoDict_withoutOwner){
	            if(albedoDict_withoutOwner.Count == 0){ return; }
	            base.OnImportCustomImage_OK( GenerationData_Kind.UvTextures_FromFile, albedoDict_withoutOwner );
	            Debug.Assert(albedoDict_withoutOwner.All( kvp=>kvp.Key==null) );//alls hould have been destroyed by now
	            string msg = $"Images Merged. GPU memory reduced :)";
	            Viewport_StatusText.instance.ShowStatusText(msg, false, 8, false);
	        }
	    }


	    //don't forget to destroy the textures when no longer needed, to avoid memory leaks!
	    public override void GetTextures_FromAllIcons( Action<List<Texture2D>> onReady_TexturesWithoutOwner ){
        
	        var sd = StableDiffusion_Hub.instance;
	        bool cantProceed = _genGUID_to_iconGroup.Count == 0 ||
	                           sd._finalPreparations_beforeGen || //avoid collapsing with in-progress textures.
	                           sd._generating;

	        var textureList = new List<Texture2D>();
	        if(cantProceed){ 
	            onReady_TexturesWithoutOwner?.Invoke(textureList);
	            return;
	        }
        
	        Save_MGR.instance.MergeIcons( onHaveAlbedo, oldIcons_survive: true);

	        void onHaveAlbedo(Dictionary<Texture2D, UDIM_Sector> albedoDict_withoutOwner) {
	            textureList = albedoDict_withoutOwner.OrderBy(kvp => kvp.Value.ToInt())//ensure textures are sorted by their sector.
	                                                 .Select(kvp => kvp.Key)//only care about textures.
	                                                 .ToList();
	            onReady_TexturesWithoutOwner?.Invoke(textureList);
	        }
	    }


    
	    // extract the painted colors and make them into a UV texture.
	    // Works with all udims.
	    void OnBakeColorsButton(){
	        var kind = GenerationData_Kind.UvPaintedBrush;
	        List<UDIM_Sector> u_sectors;
	        List<Texture2D> textures = Inpaint_MaskPainter.instance.ExtractColorLayer_as_UV_texture2D(out u_sectors);
	        //we'll be showing colors via extracted texture, now, clear the buffers to avoid showing two at once:
	        Inpaint_MaskPainter.instance.ResetPaintMask();

	        var textures_without_owner = new Dictionary<Texture2D, UDIM_Sector>();
	        for(int i=0; i<textures.Count;i++){
	            Texture2D t   = textures[i];
	            UDIM_Sector u = u_sectors[i];
	            textures_without_owner.Add(t,u);
	        }
	        base.OnImportCustomImage_OK(kind, textures_without_owner);
	    }



	    void On_will_import_3d_model(ModelsHandler_ImporingInfo info){
	        if(info.isKeep_Art2D_Icons){ return; }
	        var genDict = GenData2D_Archive.instance;
	        List<GenData2D> proj_genData = genDict.FindAll_GenData_ofKind(GenerationData_Kind.SD_ProjTextures);
	        List<GenData2D> tex_genData = genDict.FindAll_GenData_ofKind(GenerationData_Kind.UvTextures_FromFile);
	        proj_genData.ForEach(d=>genDict.DisposeGenerationData(d.total_GUID));
	        tex_genData.ForEach(d=>genDict.DisposeGenerationData(d.total_GUID));
	    }


	    // Even if this UI panel's game object is disabled (other panels are showing),
	    // We still keep getting callbacks here. Useful for handling input.
	    void OnUpdate_evenIfDisabled(){
	        SelectIconGroup_ByKeyboard_maybe(isIncrement:true);
	        SelectIconGroup_ByKeyboard_maybe(isIncrement:false);
	        ChangePriority_IconGroup_maybe(isMoveEarlier:true);
	        ChangePriority_IconGroup_maybe(isMoveEarlier:false);
	        IconGroupVisibility_byShortcuts();
	    }


	    void IconGroupVisibility_byShortcuts(){
	        if(KeyMousePenInput.isSomeInputFieldActive()){ return; }//might be typing something in text-prompt, etc.
	        if(KeyMousePenInput.isRMBpressed()){ return; }//we're possibly "flying/walking around" (Q/E is then used to fly up/down)
	        bool ctrlPressed = KeyMousePenInput.isKey_CtrlOrCommand_pressed();
	        bool change_isHide = Keyboard.current.qKey.wasPressedThisFrame && !ctrlPressed;
	        bool change_isSolo = Keyboard.current.qKey.wasPressedThisFrame && ctrlPressed;

	        if(_mainSelectedIcon == null){ return; }
	        ArtIconsGroup grp =  _mainSelectedIcon._myIconGroup;

	        if(change_isHide){
	            var visibil =  grp.hideMyIcons_please? ArtIconsGroup.GroupVisibility.DontHide : ArtIconsGroup.GroupVisibility.Hide;
	            base.ChangeVisibility_of_IconGroup(_mainSelectedIcon, visibil);
	        }
	        if(change_isSolo){
	            var visibil =  grp.showMyIcons_as_solo? ArtIconsGroup.GroupVisibility.DontSolo : ArtIconsGroup.GroupVisibility.Solo;
	            base.ChangeVisibility_of_IconGroup(_mainSelectedIcon, visibil);
	        }
	    }
    

	    void SelectIconGroup_ByKeyboard_maybe(bool isIncrement){
	        View_UserCamera cam = UserCameras_MGR.instance?._curr_viewCamera;
	        if (cam == null){ return; }//scene are probably still loading

	        if (cam.cameraOrbit._isOrbiting){ return; }
	        if (cam.cameraDolly._isZooming){ return; }
	        if (!MainViewport_UI.instance.isCursorHoveringMe()  &&  Art2D_IconsUI_List.instance._hovered_icon==null){ return; }
	        if (KeyMousePenInput.isRMBpressed()){ return; }
	        if (Keyboard.current.shiftKey.isPressed || KeyMousePenInput.isKey_CtrlOrCommand_pressed()) { return; }
	        if (KeyMousePenInput.isSomeInputFieldActive()){ return; }//typing text etc.
	        if (DimensionMode_MGR.instance._dimensionMode!=DimensionMode.dim_sd){ return; }

	        bool wasA = Keyboard.current.aKey.wasPressedThisFrame;
	        bool wasD = Keyboard.current.dKey.wasPressedThisFrame;
	        if(!isIncrement && !wasA){ return; }
	         if(isIncrement && !wasD){ return; }
        
	        Select_NextIconGroup(isIncrement);
	        //scroll the content of scroll rect, to ensure the item is visible.
	        //Invoke manually, without any kind of events:
	        OnScrollToIcon_after_LayoutRebuilt();
	    }

    
	    void Select_NextIconGroup(bool increment){
	        Guid currIcon_guid = default; 
        
	        if(_mainSelectedIcon!=null){
	            currIcon_guid= _mainSelectedIcon._genData.total_GUID;
	        }
	        List<Guid> gen_guids =  base.guid_ordered_in_grid_refDontAlter();
	        int currIconIx  =  gen_guids.IndexOf(currIcon_guid);
	        if(currIconIx<0){ return; }

	        currIconIx +=  increment ? 1 : -1;
	        if(currIconIx >= gen_guids.Count){ currIconIx = 0; }
	        if(currIconIx < 0){  currIconIx = gen_guids.Count-1;  }

	        currIcon_guid = gen_guids[currIconIx];
	        IconUI icon   = base.GetIcon_of_GenerationGroup(currIcon_guid, -1, justGetChosenIcon:true);
	        IconUI.Act_OnSomeIconClicked(icon, icon._genData.kind);

	        UserCameras_MGR.instance.Restore_CamerasPlacements(icon._genData);
	    }


	    void ChangePriority_IconGroup_maybe(bool isMoveEarlier){
	        //NOT USED NOVEMBER 2024.  Preventing movement of icons, because Save/Load gets broken.
	        //Icon's dragging ui element is also kept inactive 'grab-ribbon (click me to drag whole IconUI)'
	        return;
	        // if(_mainSelectedIcon == null){ return; }
	        // if(_mainSelectedIcon.myDraggableScript == null){ return; }
	        // 
	        // View_Camera cam = UserCameras_MGR.instance._curr_viewCamera;
	        // if (cam.cameraOrbit._isOrbiting){ return; }
	        // if (cam.cameraDolly._isZooming){ return; }
	        // if (!MainViewport_UI.instance.isCursorHoveringMe()  &&  _hovered_icon==null){ return; }
	        // if (KeyMousePenInput.isRMBpressed()){ return; }
	        // if (Keyboard.current.shiftKey.isPressed || KeyMousePenInput.isKey_CtrlOrCommand_pressed()) { return; }
	        // if (KeyMousePenInput.isSomeInputFieldActive()) { return; }//typing text etc.
	        // 
	        // var dragScript =  base._mainSelectedIcon.myDraggableScript;
	        //  if(isMoveEarlier && !Keyboard.current.wKey.wasPressedThisFrame){ return; }
	        // if(!isMoveEarlier && !Keyboard.current.sKey.wasPressedThisFrame){ return; }
	        // 
	        // _draggableItemsGrid.MoveItem_and_its_Siblings(dragScript, isMoveEarlier);
	        // //scroll the content of scroll rect, to ensure the item is visible:
	        // _draggableItemsGrid._onUpdatedLayout_afterRearrange += OnScrollToIcon_after_LayoutRebuilt;
	    }


	    //scrolls the content of scroll rect, to ensure the main item is visible:
	    void OnScrollToIcon_after_LayoutRebuilt(){
	        _draggableItemsGrid._onUpdatedLayout_afterRearrange -= OnScrollToIcon_after_LayoutRebuilt;
	        if (_mainSelectedIcon == null){ return; }
	        if (_mainSelectedIcon.myDraggableScript == null){ return; }

	        var square =  _mainSelectedIcon.myDraggableScript.first_inSiblings._mySquare.transform as RectTransform;
	        base._sr_itemFocuser.FocusOnItemLocalPos(square);
	    }


	    protected override void Update(){
	        base.Update();
	        // If there are too many icons, pulsate the merge-all button.
	        // It hints user that it's time to collapse icons:
	        bool pulsate_mergeAll =  base.num_all_my_icons() > 25; //total in all generations
	        _header.OnPulsate_MergeAll_Button(pulsate_mergeAll);
	    }


	    public void OnExportAllIcons_Button(){
	        ConfirmPopup_UI.instance.Show("Dump all Art images into a folder?\nThis might take some time.\n<b>Can overwrite existing files!</b>", onYes, null);
	        void onYes(){
	            // CHANGED: Using SimpleFileBrowser for Folder Selection
	            FileBrowser.ShowLoadDialog((paths) => {
	                if(paths.Length == 0) return;
	                string folderPath = paths[0];

	                List<IconUI> icons = base.allMyIcons();
	                List<Texture2D> textures = new List<Texture2D>();
	                List<Texture2D> toBeDestroyed = new List<Texture2D>();

	                try {
	                    foreach(IconUI i in icons){
	                        Dictionary<Texture2D,UDIM_Sector> texs = i._genData.GetTextures2D_expensive(out bool destroyWhenDone);
	                        List<Texture2D> keys = texs.Keys.ToList();

	                        textures.AddRange(keys);
	                        if(destroyWhenDone){ toBeDestroyed.AddRange(keys); }
	                    }

	                    for(int i=0; i<textures.Count; ++i){
	                        if (textures[i] == null){ continue; }
	                        string tex_path = Path.Combine(folderPath, $"tex_{i}.png");
	                        TextureTools_SPZ.EncodeAndSaveTexture(textures[i], tex_path);
	                    }
	                    Viewport_StatusText.instance.ShowStatusText("Exported all Art images", false, 4, false);
	                }
	                catch(Exception e){
	                    Debug.LogException(e);
	                    Viewport_StatusText.instance.ShowStatusText("Failed to export some Art images", false, 4, false);
	                }
	                finally { 
	                    //cleanup
	                    foreach (Texture2D tex in toBeDestroyed){ DestroyImmediate(tex); }
	                }

	            }, null, FileBrowser.PickMode.Folders, false, null, null, "Select Export Folder", "Select");

	        }//end onYes()
	    }


	    public override void Save( StableProjectorz_SL spz ){
	        spz.art2D_iconList = new Art2D_IconsList_SL();
	        spz.art2D_iconList.header = new Art2D_IconsList_Header_SL();
	        _header.Save(spz.art2D_iconList.header);
	        base.OnSaveCommonStuff(spz.art2D_iconList);
	        // After base is saved, ensure we store the guid of BASE CLASS's icon
	        // That's because our own overload might pretend that there is no icon:
	        spz.art2D_iconList._mainSelectedIcon_groupGuid = base._mainSelectedIcon?.generation_guid.ToString() ?? "";
	    }

	    public override void Load(StableProjectorz_SL spz){
	        _header.Load( spz.art2D_iconList.header );
	        base.OnLoadCommonStuff( spz.art2D_iconList );
	    }


	    protected override void Awake(){
	        if(instance != null){ DestroyImmediate(this); return; }
	        instance = this;
	        base.Awake();
	        ModelsHandler_3D.Act_onWillLoadModel += On_will_import_3d_model;
	        CallbackEveryFrame_MGR.onUpdate += OnUpdate_evenIfDisabled;
	        WorkflowRibbon_UI.Act_onBakeColors_button += OnBakeColorsButton;
	        ExportSave_UI_MGR.OnExportAllArt_Icons_Button += OnExportAllIcons_Button;
	    }

	    protected override void OnDestroy(){
	        ModelsHandler_3D.Act_onWillLoadModel -= On_will_import_3d_model;
	        CallbackEveryFrame_MGR.onUpdate -= OnUpdate_evenIfDisabled;
	        base.OnDestroy();
	    }

	}
}//end namespace
